import numpy as np
from scipy.optimize import minimize
import matplotlib.pyplot as plt

# Define a cubic polynomial trajectory for a single drone
def cubic_trajectory(t, coeffs):
    """Compute 2D position for a cubic polynomial: p(t) = c0 + c1*t + c2*t^2 + c3*t^3"""
    x = coeffs[0] + coeffs[1] * t + coeffs[2] * t**2 + coeffs[3] * t**3
    y = coeffs[4] + coeffs[5] * t + coeffs[6] * t**2 + coeffs[7] * t**3
    return np.array([x, y])

# Objective function: smoothness + obstacle avoidance + inter-drone collision avoidance
def objective_function(coeffs, t_samples, obstacles, other_drones, clearance=0.2, drone_id=0):
    smoothness = np.sum((3 * coeffs[3] * t_samples + 2 * coeffs[2])**2 + 
                        (3 * coeffs[7] * t_samples + 2 * coeffs[6])**2)  # Minimize jerk
    obstacle_penalty = 0
    collision_penalty = 0
    
    for t in t_samples:
        pos = cubic_trajectory(t, coeffs)
        # Obstacle avoidance
        for obs in obstacles:
            dist = np.linalg.norm(pos - obs)
            if dist < clearance:
                obstacle_penalty += (clearance - dist)**3  # Penalty as in paper
        # Inter-drone collision avoidance
        for i, other_coeffs in enumerate(other_drones):
            if i != drone_id:  # Skip self
                other_pos = cubic_trajectory(t, other_coeffs)
                dist = np.linalg.norm(pos - other_pos)
                if dist < clearance:
                    collision_penalty += (clearance - dist)**3  # Penalty for swarm
    
    return smoothness + 1000 * obstacle_penalty + 1000 * collision_penalty

# Simulate a single drone's trajectory
def plan_trajectory(start, goal, obstacles, other_drones, drone_id, t_samples):
    # Initial guess: linear interpolation between start and goal
    initial_guess = np.zeros(8)
    initial_guess[0] = start[0]  # x0
    initial_guess[4] = start[1]  # y0
    initial_guess[1] = goal[0] - start[0]  # Linear x velocity
    initial_guess[5] = goal[1] - start[1]  # Linear y velocity
    
    # Optimize trajectory
    result = minimize(
        objective_function,
        initial_guess,
        args=(t_samples, obstacles, other_drones, drone_id),
        method='SLSQP',
        bounds=[(-10, 10)] * 8,  # Reasonable bounds for coefficients
        options={'maxiter': 100}
    )
    return result.x

# Simulation parameters
num_drones = 3
t_samples = np.linspace(0, 1, 50)  # Time samples for trajectory
obstacles = np.array([[0.5, 0.5], [0.7, 0.3], [0.4, 0.7]])  # Static obstacles
clearance = 0.2  # Minimum clearance (meters)
starts = np.array([[0.0, 0.0], [0.1, 0.1], [0.0, 0.2]])  # Start positions
goals = np.array([[1.0, 1.0], [0.9, 0.9], [1.0, 0.8]])  # Goal positions

# Plan trajectories for all drones
trajectories = []
for i in range(num_drones):
    # Use previous drones' trajectories for collision avoidance
    coeffs = plan_trajectory(starts[i], goals[i], obstacles, trajectories, i, t_samples)
    trajectories.append(coeffs)

# Visualize results
plt.figure(figsize=(8, 8))
for i, coeffs in enumerate(trajectories):
    positions = np.array([cubic_trajectory(t, coeffs) for t in t_samples])
    x, y = positions[:, 0], positions[:, 1]
    plt.plot(x, y, label=f"Drone {i+1}")
    plt.scatter([starts[i][0], goals[i][0]], [starts[i][1], goals[i][1]], 
                marker='o', s=100, label=f"Drone {i+1} Start/Goal")

# Plot obstacles
for obs in obstacles:
    circle = plt.Circle(obs, clearance, color='red', alpha=0.3)
    plt.gca().add_patch(circle)
plt.scatter(obstacles[:, 0], obstacles[:, 1], color='red', label="Obstacles")

plt.xlabel("X (m)")
plt.ylabel("Y (m)")
plt.title("Swarm Navigation in 2D Cluttered Environment")
plt.legend()
plt.grid(True)
plt.axis('equal')
plt.show()